\begin{enumerate}
    \item Написать свой \textbf{stat}. 
    
    Напечатать в терминале фразу \textbf{stat *имя файла*}, посмотреть что она выдает. И написать программу по образу и подобию. Дабы это было легче делать, то стоит прочесть такую замечательную штуку как \textbf{man}. В командной строке необходимо набрать $man\ 2\ lstat$ и наслаждатьс чтением, а так же почти что написанным за вас кодом в этом самом \textbf{man}. Так же для сдачи задачи необходимо понимать чем отличаются следующие команды \textbf{lstat, statx, fstat, fstatat}. 
    \item
    \begin{enumerate}
        \item Записать в указанный файл, содержимое указанное в строке. Программа подразумевает под собой использование вызова \textbf{open, write, close}.  
        \item Понять что уществует еще и такой вызов как \textbf{dprintf}. Проделать тоже самое, что было проделано в 2.a. 
    \end{enumerate}
    
    \item 
    
    \begin{enumerate}
        \item Теперь пора переходить к большим масштабам и копировать не просто содержимое какой-то строчки, а целого файла. Для этого знакомимся с таким системным вызовом как \textbf{read} и сочетаем его с системным вызовом \textbf{write}. 
        
        \item Познакомится с такими штуками как \textbf{pread, pwrite} и сделать все тоже самое, что в 3.a. 
        
        \item Научится копировать не только обычные файлы, но и прочие штучки, такие как FIFO, символьные ссылки, блочные и символьные устройyства. Для этого используем такие штуки как \textbf{mknod, mkfifo, readlink, symlink.}   
    \end{enumerate}
    
    \item Учимся изменять атрибуты у наших скопированных файлов и не только. Для этого используем \textbf{fchmod, futimens}. 
    
    \item Копируем UID и GID для этого используем \textbf{fchown} 
    \item 
    \begin{enumerate}
        \item Читаем содержимое дирректории и вывожим на экран на подобии ls -la \textbf{opendir, readdir, closedir} 
        
        \item Аналогично 6.a только для каталога, указанного пользователем. Используем \textbf{opendir, dirfd, fstatat, readdir, closedir} 
        
        \item Решить задачу 6.1, но вместо всего прекрасного использовать getdents. 
        
        \item Рекурсивно реализовать 6.2. 
    \end{enumerate}
    
    \item 
    
    \begin{enumerate}
        \item Копировать директорию. Используем \textbf{openat, mkdirat}. 
        \item Рекурсивно копировать директорию. 
    \end{enumerate}
    
    \item Вывести физическое размещение файла на диске. С помощью strace посмотреть какие системные вызовы дергают уилиты hdparm--fibmap  \textbf{filefrag hdparm--fibmap}. 
    
    \item 
    \begin{enumerate}
        \item Вывести занятое, свободное и доступное место пространство для файловой системы на которой расположен указанный файл или каталог. Используем \textbf{statvfs, statfs}. 
    
    \item \textbf{quota, quotactl}    
    \end{enumerate}
    
    \item Напечатать информацию о появлении новых файлов в указанном каталоге. Отслеживаем с помощью \textbf{inotify}. Код программы есть в man. 
    
    \item Файловые блокировки. О том, что если несколько программ работают с одним файлом, то им нужно синхронизировать свои действия, иначе ничего хорошего не получится. Если программы будут действовать одновременно, то содержимое файла превратится в кашу. 
    
    Соответственно требуется написать программу, которая бы подсчитывала сколько раз она запускалась. В другом файле \textbf{counter.txt} отсчитывать количесво запусков (считая текущий) и коректно отрабатывать параллельные запуски.  
    
    Используется \textbf{flock, lockf, fcntl-lock}. 
    
    \item  $\ast$ Вывести информацию про текущий процесс (про запущенный экземпляр этой программы)
id выводить по порядку как в $credentials(7)$ --- иерархия процессов, группы (по кучкам)
$getgroups(2)$. Читаем \textbf{edentials, sched, capabilities}. Используем \textbf{prlimit, getlimit}.

    \item 
    \begin{enumerate}
        \item Написать программу, которая порождает дочерний процесс и ждет его завершения, затем выводит информацию о завершении дочернего процесса. Используем \textbf{wait, waitpid, waitid}.
        Пример в man 2 $waitpid$
        \item Программа порождает дочерний процесс, он дожидается завершения родительского процесса. Мониторить $parentpid$, если он изменился, то родитель умер. 
 \end{enumerate}
 
    \item 
    \begin{enumerate}
        \item \textbf{dup 2}  
        \item \textbf{execve} 
        \item \textbf{pipe} Вывести то же самое, что $last | wc -l$
(на основе 14.1) реализовать использование других программ из своей
соединить $stdout$ одной программы с $stdin$ другой программы(команды пишут на вход друг другу)
        \item Написать программу, которая в дочернем процессе запускает $gzip$, работая с ним через два пайпа; померять скорость, с которой $gzip$ сжимает случайные данные \textbf{poll/select}. 
    \end{enumerate}
    \item \begin{enumerate}
        \item Написать программу, которая не завершается используя сигналы \textbf{signal, sigaction}
        \item Модифицировать inotify так, чтоб он корректно завершался 10 + termination
        \item $\ast$  \textbf{signalfd, sigqueue} 
    \end{enumerate}
    \item Создать очередь сообщений $(mq\_open)$, посмотреть на ее параметры $(mq\_getattr)$, в конце почистить $(mq\_close + mq\_unlink)$ \textbf{mq\_open, mq\_getattr, mq\_close, mq\_unlink} 
    \item Написать две программы

одна всегда запущена(сервер):
    создает очередь сообщений, 
    в бесконечном цикле читает $(mq\_receive)$ все сообщения(и время, когда оно прилетело)
    печатает (нет \0, печатать printf ом аккуратно); 
    когда приходит сигнал, удаляет очередь
вторая (клиент):
    открывает очередь
    посылает туда сообщение
    закрывает очередь
!сначала закрыть дескриптор очереди, только потом в цикле обрабатывать все сообщения\textbf{mk\_send, mk\_receive} 
    \item Использовать команды \textbf{dlopen, dlsym, dlclose} для написания интегрирования. 
    \item 
        \begin{enumerate}
            \item \textbf{pthread\_mutex\_t} 
            \item \textbf{sem\_init, sem\_wait, sem\_post, sem\_destroy} 
            \item \textbf{sem\_open, sem\_close, sem\_unlink}
            \item \textbf{atomit\_fetch\_add, atomic\_load}
            \item \textbf{map-reduce approach} 
        \end{enumerate}
    \item $shm\_server:$ 
    
    создает область общей памяти \textbf{clock (shm\_open + ftruncate)}, отображает ее в свое адресное пространство $mmap$, инициализирует область \textbf{sem\_init} 
    раз в секунду пишет в нее строку с временем \textbf{localtime+strftime}, 
    по $SIGINT/SIGTERM$  прекращает цикл, и удаляет область общей памяти $shm\_unlink$
    
    $shm\_client:$ 
    
    открывает $/clock$ на чтение $shm\_open$ и отображает $mmap$, в цикле раз в секунду печатает строку из этой области, по $SIGINT/SIGTERM$ прекращает цикл. 
    
    Не забываем про синхронизацию! ($sem\_init$ в сервере + $sem\_wait/sem\_post$ в обоих).
    
    \item  UDP-сервер времени.
На пакет с некоторым запросом отвечает пакетом со строкой с текущим временем.  

    \item  TCP-сервер времени.
Принимает соединения, раз в секунду в каждое живое соединение отправляет
строку с текущим временем, формат: %Y-%m-%d %H:%M:%S\n (см. man strftime)

Плохой/злонамеренный клиент не должен иметь возможности обрушить или завесить сервер.  
    

\end{enumerate}